/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

package Vista;

/**
 *
 * @author lissette
 */
public class FRM_InformacionQuicksort extends javax.swing.JFrame {

    /**
     * Creates new form FRM_InformacionQuicksort
     */
    public FRM_InformacionQuicksort() {
        initComponents();
        setLocation(750,200);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jLabel1 = new javax.swing.JLabel();

        setMaximumSize(new java.awt.Dimension(620, 400));
        setMinimumSize(new java.awt.Dimension(620, 400));
        setPreferredSize(new java.awt.Dimension(620, 400));
        setResizable(false);
        getContentPane().setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        jTextArea1.setBackground(new java.awt.Color(177, 203, 46));
        jTextArea1.setColumns(20);
        jTextArea1.setFont(new java.awt.Font("Ubuntu Light", 1, 18)); // NOI18N
        jTextArea1.setRows(5);
        jTextArea1.setText(" El ordenamiento por partición (Quick Sort) se puede definir en una forma más\nconveniente como un procedimiento recursivo.\nTiene aparentemente la propiedad de trabajar mejor para elementos de \nentrada desordenados completamente, que para elementos semiordenados.\n Esta situación es precisamente la opuesta al ordenamiento de burbuja.\nEste tipo de algoritmos se basa en la técnica \"divide y vencerás\", o sea es más\nrápido y fácil ordenar dos arreglos o listas de datos pequeños , que un arreglo\no lista grande.\nNormalmente al inicio de la ordenación se escoge un elemento aproximadamente\nen la mitad del arreglo, así al empezar a ordenar, se debe llegar a que el arreglo\neste ordenado respecto al punto de división o la mitad del arreglo.\nSe podrá garantizar que los elementos a la izquierda de la mitad son los menores\n y los elementos a la derecha son los mayores.\nLos siguientes pasos son llamados recursivos con el propósito de efectuar la \nordenación por partición al arreglo izquierdo y al arreglo derecho, que se \nobtienen de la primera fase. El tamaño de esos arreglos en promedio se reduce a la mitad.\nAsí se continúa hasta que el tamaño de los arreglos a ordenar es 1, es decir, todos los elementos  ya están ordenados.\nEn promedio para todos los elementos de entrada de tamaño n, el método hace O(n log n) comparaciones, el cual es relativamente eficiente.");
        jScrollPane1.setViewportView(jTextArea1);

        getContentPane().add(jScrollPane1, new org.netbeans.lib.awtextra.AbsoluteConstraints(20, 20, 580, 340));

        jLabel1.setIcon(new javax.swing.ImageIcon(getClass().getResource("/img/fondoTriangulo.jpg"))); // NOI18N
        jLabel1.setMaximumSize(new java.awt.Dimension(630, 408));
        jLabel1.setMinimumSize(new java.awt.Dimension(630, 408));
        jLabel1.setPreferredSize(new java.awt.Dimension(626, 408));
        getContentPane().add(jLabel1, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, -30, 630, 470));

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * @param args the command line arguments
     */
   

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextArea jTextArea1;
    // End of variables declaration//GEN-END:variables
}
